<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>App</title>
<script src="Oimo.js"></script>
<script src="babylon.2.1.debug.js"></script>
<script src="Lib.js"></script>
<script src="dat.gui.min.js"></script>

    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
    <body>
    
	 <canvas id="renderCanvas"></canvas>
	 
	 <script>
    if (BABYLON.Engine.isSupported()) {
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);
        var scene = new BABYLON.Scene(engine); 
        
    	//Create an ArcRotateCamera aimed at 0,0,0, with no alpha, beta or radius, so be careful.  It will look broken.
        //var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 0, 0, 0, BABYLON.Vector3.Zero(), scene);

		scene.gravity = new BABYLON.Vector3(0, -0.81, 0);
		
        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, -1, 1), scene);

      	//Pressing W
		camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(0,0,0.1));
        //Pressing S
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(0,0,-0.1));
        //Pressing A
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(-0.1,0,0));	
        //Pressing D 
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(0.1,0,0));
        
		//camera.applyGravity = true; 
		
		camera.angularSensibility = 3000;
		camera.speed = 0.2;
		
		scene.workerCollisions = true;
		
		//camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);
		
		// Enable Collisions
		scene.collisionsEnabled = true;
		//camera.checkCollisions = true;
		
        // Quick, let's use the setPosition() method... with a common Vector3 position, to make our camera better aimed.
        //camera.setPosition(new BABYLON.Vector3(0, 15, -30));
        
        var mouse = new BABYLON.Vector2();
        
        function onDocumentMouseMove( event ) {
           mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
        }
        
        scene.activeCamera.attachControl(canvas);
		scene.debugLayer.show(true);
		scene.workerCollisions = true;
		
		var configObject = {
			targetFPS: 50,
			useSIMD: false
		};

		
		try
		{
						
			BABYLON.SIMDHelper.EnableSIMD();
			
			
			configObject.useSIMD = BABYLON.SIMDHelper.IsEnabled;
			
			// GUI
			var gui = new dat.GUI();
			gui.add(configObject, 'targetFPS', 10, 60);
			gui.add(configObject, 'useSIMD').onChange(function () {
				
				//if (BABYLON.SIMDHelper.IsEnabled) {
				//									alert('SIMDEnabled');
				//	BABYLON.SIMDHelper.DisableSIMD();
				//} else {

					
				//}

				configObject.useSIMD = BABYLON.SIMDHelper.IsEnabled;
			});
			
		}
		catch(e)
		{
			alert(e.message);
		}
		
		//You’re setting up the gravity level (-10 on the Y axis in this sample code, which is more or less like what we have on Earth) and 
		//the physics engine you’d like to use. We’ll use Oimo.js but the commented line shows how to use cannon.js.
        //scene.enablePhysics(new BABYLON.Vector3(0, -10, 0), new BABYLON.OimoJSPlugin());
        
        /*
        camera.radius = 30; // how far from the object to follow
        camera.heightOffset = 8; // how high above the object to place the camera
        camera.rotationOffset = 180; // the viewing angle
        camera.cameraAcceleration = 0.05 // how fast to move
        camera.maxCameraSpeed = 20 // speed limit
        */

        var meshesColliderList = [];
        
		
		/*BABYLON.SceneLoader.Load("", "FP.incremental.babylon", engine, function (newScene) {
            // Wait for textures and shaders to be ready
            newScene.executeWhenReady(function () {
                // Attach camera to canvas inputs
                newScene.activeCamera.attachControl(canvas);

                // Once the scene is loaded, just register a render loop to render it
                engine.runRenderLoop(function() {
                    newScene.render();
                });
            });
        }, function (progress) {
            // To do: give progress feedback to user
        });
		*/
		

        BABYLON.SceneLoader.ImportMesh("", "./",  "NewStore.incremental.babylon" , scene, function (newMeshes, particleSystems, skeletons)
        		{
				camera.target = newMeshes[0];
    			   console.log('loading Meshes');
            var scale = 10;
            var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
            //groundMaterial.reflectionTexture = new BABYLON.MirrorTexture("mirror", 1024, scene, true);
            //groundMaterial.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, -1.0, 0, 0);
            //groundMaterial.reflectionTexture.renderList = [newMeshes[0], newMeshes[1]];
            //groundMaterial.reflectionTexture.level = 0.5;

            groundMaterial.diffuseTexture = new BABYLON.Texture("mirror.jpg", scene);
            groundMaterial.diffuseTexture.uScale = scale;
            groundMaterial.diffuseTexture.vScale = scale;
            groundMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
            groundMaterial.specularColor = new BABYLON.Color3(1.0, 1.0, 1.0);
            // ceilingMaterial.bumpTexture = new BABYLON.Texture("fp1.jpg", scene);
            // ceilingMaterial.bumpTexture.uScale = scale;

            // Ground
            var ground = BABYLON.Mesh.CreateGround("ground", 1000, 1000, 1, scene, false);

            //groundMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
            //groundMaterial.specularColor = new BABYLON.Color3(1, 1, 1);

            ground.material = groundMaterial;
            ground.receiveShadows = true;
					//ground.checkCollisions = true;
			
			var positionObj = newMeshes[200];
						
						//positionObj.addLODLevel(20, null);
			
						for (var count = 0; count < newMeshes.length; count++) {
							var offsetX = newMeshes[count].position.x + (count * 2);
							var offsetZ = newMeshes[count].position.z;
							var instance = positionObj.createInstance("instance" + count);

							instance.position = positionObj.position.clone();

							instance.position.x += offsetX;
							instance.position.z -= offsetZ;
						}

			
					

    		        for (var i = 0; i < newMeshes.length; i++) {
						//newMeshes[i].visibility = 0.1;
						newMeshes[i].subdivide(20);
						
						newMeshes[i].setLODCallBackFunc(function (dist, LODMesh){
							if (dist < 25) {
								this.visibility = (-dist + 25) / 3.0;
							}	
							else{
								//this.dispose();
							}
							//else{
							//this.visibility = 0.4;
							//}
							//console.log(dist);
							if (dist < 10) {
								
								try{
									//console.log(this.name);
									this.LoadData(scene, this.name);
									/*(function(self){
										setTimeout(function(){ self.LoadData(scene, self.name); }, 3000);
									})(this);*/
									
									//setInterval(function(){this.LoadData(scene, this.name);}, 100),
								}							//else{
								catch(e){
									
								}
							}
							else{
							}
						});
							
						
						/*newMeshes[i] && newMeshes[i].simplify([{ quality: 0.5, distance: 5 }], 
						true, BABYLON.SimplificationType.QUADRATIC, function() {
							//console.log("LOD finished, let's have a beer!", i);
							//newMeshes[i].visibility = 1;
							
							//BABYLON.SceneLoader.ImportMesh("", "./", "plano1.babylon", scene, function (newMeshes1, particleSystems1, skeletons1){
								//console.log('loading sub scene', newMeshes[i] ? newMeshes[i].name : 'NA');
							//}); 
							
						});*/
						
						try{
							
							newMeshes[i].checkCollisions = true;

							//if (newMeshes[i].checkCollisions && newMeshes[i].isVisible === false) {
							newMeshes[i].setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 0, 
	    		                                            friction: 0.5, restitution: 0.7 });
							meshesColliderList.push(newMeshes[i]);
						
							newMeshes[i].addLODLevel(30, null);
												
							//newMeshes[i] && newMeshes[i].optimizeIndices(function() {
								//alert('optimized');
								//newMeshes[i] && newMeshes[i].simplify([{distance:20, quality:0.9}, {distance:30, quality:0.8}, {distance:40, quality:0.7}, {distance:	50, quality:0.6}]);
							//});
							
							//newMeshes[i].convertToFlatShadedMesh();
							//newMeshes[i].addLODLevel(20, null);
							
							//newMeshes[i] && newMeshes[i].optimizeIndices(function() {
							//	newMeshes[i] && newMeshes[i].simplify([{distance:20, quality:0.9}, {distance:30, quality:0.8}, {distance:40, quality:0.7}, {distance:	50, quality:0.6}]);
							//});
													
							
							
						}
						catch(e)
						{
						
						}
    		        }
            // ceiling
            /*
            var ceiling = BABYLON.Mesh.CreateCeiling("ceiling", 1000, 1000, 100, scene, false);
            var scale = 10;//10
            var ceilingMaterial = new BABYLON.StandardMaterial("ceilingMaterial", scene);
            ceilingMaterial.diffuseTexture = new BABYLON.Texture("fp.jpg", scene);
            ceilingMaterial.diffuseTexture.uScale = scale;
            ceilingMaterial.diffuseTexture.vScale = scale;
            ceilingMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
            ceilingMaterial.specularColor = new BABYLON.Color3(1.0, 1.0, 1.0);
            ceilingMaterial.bumpTexture = new BABYLON.Texture("fp1.jpg", scene);
            ceilingMaterial.bumpTexture.uScale = scale;
            ceilingMaterial.bumpTexture.vScale = scale;
            ceiling.material = ceilingMaterial;
            ceiling.receiveShadows = false;
            */
            var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
        		});

        camera.upperAlphaLimit = 0;
        camera.lowerAlphaLimit = 0;
        camera.upperBetaLimit = 0;
        camera.lowerBetaLimit = 0;
        camera.upperRadiusLimit = 0;
		camera.lowerRadiusLimit = 0;


		// arccam.alpha = 0;
		// arccam.beta = 0; // straight overhead
		// arccam.beta = Math.PI/2; // straight-on looking +z
		// arccam.beta = Math.PI; // directly beneath looking +y
		camera.alpha = 0;
		// arccam.alpha = .707;

		camera.radius = 100;

		camera.fov = .6;

		// alert(arccam.fov);

		camera.beta = Math.PI/3; // 45
        
        /* scene.activeCamera.keysUp.push(87); // W
        scene.activeCamera.keysLeft.push(65); // A 
        scene.activeCamera.keysDown.push(83); // S 
        scene.activeCamera.keysRight.push(68); // D 
         */


        var light = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 2, 0), scene);
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        light.specular = new BABYLON.Color3(1, 1, 1);
        light.groundColor = new BABYLON.Color3(0, 0, 0);


        engine.runRenderLoop(function () {

            if (mouse.x > 0.7 || mouse.x < -0.7 || mouse.y > 0.7 || mouse.y < -0.7) {
                camera.rotation = camera.rotation.add(new BABYLON.Vector3((-mouse.y) / 100, 0, 0));
                camera.rotation = camera.rotation.add(new BABYLON.Vector3(0, (mouse.x) / 100, 0));
            }

            //scene.activeCamera.alpha += .01;
            scene.activeCamera.position.y = 1;
            scene.render();


        });
		
		// Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
		
        /*
        BABYLON.SceneLoader.Load("", "FP.babylon", engine, function (newScene) {
            // Wait for textures and shaders to be ready
            newScene.executeWhenReady(function () {
                // Attach camera to canvas inputs
                newScene.activeCamera.attachControl(canvas);

                // Once the scene is loaded, just register a render loop to render it
                engine.runRenderLoop(function() {
                    newScene.render();
                });
            });
        }, function (progress) {
            // To do: give progress feedback to user
        });
        */
    }
</script>
	 
    </body>
</html>