<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>App</title>
<script src="Oimo.js"></script>
<script src="babylon.2.0.js"></script>

    <style>
        html, body {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            overflow: hidden;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
    <body>
    <p>Starting to work now. but have to learn some stuff though</p>
    
	 <canvas id="renderCanvas"></canvas>
	 
	 <script>
    if (BABYLON.Engine.isSupported()) {
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true);
        var scene = new BABYLON.Scene(engine); 
        
    	//Create an ArcRotateCamera aimed at 0,0,0, with no alpha, beta or radius, so be careful.  It will look broken.
        //var camera = new BABYLON.ArcRotateCamera("ArcRotateCamera", 0, 0, 0, BABYLON.Vector3.Zero(), scene);

        var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 1, -15), scene);

      	//Pressing W
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(0,0,0.1));
        //Pressing S
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(0,0,-0.1));
        //Pressing A
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(-0.1,0,0));	
        //Pressing D 
        camera.cameraDirection= camera.cameraDirection.add(new BABYLON.Vector3(0.1,0,0));
        
        // Quick, let's use the setPosition() method... with a common Vector3 position, to make our camera better aimed.
        //camera.setPosition(new BABYLON.Vector3(0, 15, -30));
        
        var mouse = new BABYLON.Vector2();
        
        function onDocumentMouseMove( event ) {
           mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
           mouse.y = -( event.clientY / window.innerHeight ) * 2 + 1;
        }
        
        scene.activeCamera.attachControl(canvas);

		//You’re setting up the gravity level (-10 on the Y axis in this sample code, which is more or less like what we have on Earth) and 
		//the physics engine you’d like to use. We’ll use Oimo.js but the commented line shows how to use cannon.js.
        scene.enablePhysics(new BABYLON.Vector3(0, -10, 0), new BABYLON.OimoJSPlugin());
        
        /*
        camera.radius = 30; // how far from the object to follow
        camera.heightOffset = 8; // how high above the object to place the camera
        camera.rotationOffset = 180; // the viewing angle
        camera.cameraAcceleration = 0.05 // how fast to move
        camera.maxCameraSpeed = 20 // speed limit
        */

        var meshesColliderList = [];

        BABYLON.SceneLoader.ImportMesh("", "./", "FP.babylon", scene, function (newMeshes, particleSystems, skeletons) {
            console.log('loading Meshes');
            var scale = 10;
            var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
            //groundMaterial.reflectionTexture = new BABYLON.MirrorTexture("mirror", 1024, scene, true);
            //groundMaterial.reflectionTexture.mirrorPlane = new BABYLON.Plane(0, -1.0, 0, 0);
            //groundMaterial.reflectionTexture.renderList = [newMeshes[0], newMeshes[1]];
            //groundMaterial.reflectionTexture.level = 0.5;

            groundMaterial.diffuseTexture = new BABYLON.Texture("mirror.jpg", scene);
            groundMaterial.diffuseTexture.uScale = scale;
            groundMaterial.diffuseTexture.vScale = scale;
            groundMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
            groundMaterial.specularColor = new BABYLON.Color3(1.0, 1.0, 1.0);
            // ceilingMaterial.bumpTexture = new BABYLON.Texture("fp1.jpg", scene);
            // ceilingMaterial.bumpTexture.uScale = scale;

            // Ground
            var ground = BABYLON.Mesh.CreateGround("ground", 1000, 1000, 1, scene, false);

            //groundMaterial.diffuseColor = new BABYLON.Color3(1.0, 1.0, 1.0);
            //groundMaterial.specularColor = new BABYLON.Color3(1, 1, 1);

            ground.material = groundMaterial;
            ground.receiveShadows = true;

            for (var i = 1; i < newMeshes.length; i++) {
                if (newMeshes[i].checkCollisions && newMeshes[i].isVisible === false) {
                    newMeshes[i].setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 0,
                        friction: 0.5, restitution: 0.7
                    });
                    meshesColliderList.push(newMeshes[i]);
                }
            }
            // ceiling
            /*
            var ceiling = BABYLON.Mesh.CreateCeiling("ceiling", 1000, 1000, 100, scene, false);
            var scale = 10;//10
            var ceilingMaterial = new BABYLON.StandardMaterial("ceilingMaterial", scene);
            ceilingMaterial.diffuseTexture = new BABYLON.Texture("fp.jpg", scene);
            ceilingMaterial.diffuseTexture.uScale = scale;
            ceilingMaterial.diffuseTexture.vScale = scale;
            ceilingMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
            ceilingMaterial.specularColor = new BABYLON.Color3(1.0, 1.0, 1.0);
            ceilingMaterial.bumpTexture = new BABYLON.Texture("fp1.jpg", scene);
            ceilingMaterial.bumpTexture.uScale = scale;
            ceilingMaterial.bumpTexture.vScale = scale;
            ceiling.material = ceilingMaterial;
            ceiling.receiveShadows = false;
            */
            var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
            var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            skyboxMaterial.backFaceCulling = false;
            skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox", scene);
            skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;

        });

        camera.upperAlphaLimit = 0;
        camera.lowerAlphaLimit = 0;
        camera.upperBetaLimit = 0;
        camera.lowerBetaLimit = 0;
        camera.upperRadiusLimit = 0;
		camera.lowerRadiusLimit = 0;


		// arccam.alpha = 0;
		// arccam.beta = 0; // straight overhead
		// arccam.beta = Math.PI/2; // straight-on looking +z
		// arccam.beta = Math.PI; // directly beneath looking +y
		camera.alpha = 0;
		// arccam.alpha = .707;

		camera.radius = 100;

		camera.fov = .6;

		// alert(arccam.fov);

		camera.beta = Math.PI/3; // 45
        
        /* scene.activeCamera.keysUp.push(87); // W
        scene.activeCamera.keysLeft.push(65); // A 
        scene.activeCamera.keysDown.push(83); // S 
        scene.activeCamera.keysRight.push(68); // D 
         */


        var light = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 2, 0), scene);
        light.diffuse = new BABYLON.Color3(1, 1, 1);
        light.specular = new BABYLON.Color3(1, 1, 1);
        light.groundColor = new BABYLON.Color3(0, 0, 0);


        engine.runRenderLoop(function () {

            if (mouse.x > 0.7 || mouse.x < -0.7 || mouse.y > 0.7 || mouse.y < -0.7) {
                camera.rotation = camera.rotation.add(new BABYLON.Vector3((-mouse.y) / 100, 0, 0));
                camera.rotation = camera.rotation.add(new BABYLON.Vector3(0, (mouse.x) / 100, 0));
            }

            //scene.activeCamera.alpha += .01;
            scene.activeCamera.position.y = 1;
            scene.render();


        });
        /*
        BABYLON.SceneLoader.Load("", "FP.babylon", engine, function (newScene) {
            // Wait for textures and shaders to be ready
            newScene.executeWhenReady(function () {
                // Attach camera to canvas inputs
                newScene.activeCamera.attachControl(canvas);

                // Once the scene is loaded, just register a render loop to render it
                engine.runRenderLoop(function() {
                    newScene.render();
                });
            });
        }, function (progress) {
            // To do: give progress feedback to user
        });
        */
    }
</script>
	 
    </body>
</html>